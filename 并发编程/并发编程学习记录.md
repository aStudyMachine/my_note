# 01 | 可见性、原子性和有序性问题：并发编程Bug的源头

## 并发编程的幕后故事

### 源头之一 #:   CPU、内存、I/O 设备 三者的速度差异

- 三者之间存在速度差异 **=>** 故引入**缓存机制** . **=>** 缓存导致的**可见性问题**

- 一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为**可见性**。

- 多核(多cpu)时代  , 每个cpu 都有自己独立的缓存 ,  cpu对数据的读写总是将数据放入自己的缓存中操作 , 不同的cpu操作同一个数据对象时 , 各自的缓存对于对方来说 , 都是不可见的 , 这就是可见性问题 .  如图所示 : 

  ![多核 CPU 的缓存与内存关系图](http://assets.studymachine.cn/img/202110311643483.png)

- 代码示例 : 

  ```java
  public class Test {
  
      private static long count = 0;
  
      private void add10K() {
          int idx = 0;
          while (idx++ < 10000) {
              count += 1;
          }
      }
  
      /**
       * 开启两个线程, 各自分别对公共变量 count 执行 10000次 ++1 操作
       * 直觉上最后打印的结果应该是  20000 , 实际上由于各个线程各自维护的缓存问题 , 最终打印的结果 会 <= 20000
       */
      public static long calc() throws InterruptedException {
          final Test test = new Test();
  
          // 创建两个线程，执行 add() 操作
          Thread th1 = new Thread(test::add10K);
  
          Thread th2 = new Thread(test::add10K);
  
          // 启动两个线程
          th1.start();
          th2.start();
  
          // 等待两个线程执行结束
          th1.join();
          th2.join();
  
          return count;
      }
  
      public static void main(String[] args) throws InterruptedException {
          long calc = calc();
          System.out.println("calc = " + calc);
      }
  }
  
  ---------------------  打印结果 -----------------------
  calc = 17132
  ```

  



### 源头之二：线程切换带来的原子性问题

- 背景 : 我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的`count += 1`，至少需要三条 CPU 指令。
  - 指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；
  - 指令 2：之后，在寄存器中执行 +1 操作；
  - 指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。

- 所以 , 就CPU的层面上 , 高级语言执行的一条语句 , 并不是原子性(**我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性**)的. 
- 非原子操作的执行路径示意图 : 
 ![非原子操作的执行路径示意图](http://assets.studymachine.cn/img/202111020040520.png)

 - 两个线程同时对 count + 1操作 , 由于A +1未完成 , 线程切换到B , B +1 完成 写入内存 , 此时count = 1 , 线程切换回A , A中缓存的结果是 count = 0 ,  此时执行 + 1 操作 , count = 0 + 1 = 1 , 写入内存 , 导致最终的结果是1 , 而不是2 . 





### 源头之三：编译优化带来的有序性问题

- 编译器为了优化性能，有时候会**改变程序中语句的先后顺序**，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”

  - 经典示例 :  Java 双重检查创建单例对象 . 

    ```java
    public class Singleton {
      static Singleton instance;
      static Singleton getInstance(){
        if (instance == null) {
          synchronized(Singleton.class) {
            if (instance == null)
                // 问题关键点 new 操作
              instance = new Singleton();
            }
        }
        return instance;
      }
    }
    ```

    - 问题的关键点主要在 `new Singleton();` 上 .  new 的底层操作顺序被优化

    - 我们所理解的 new 一个对象的过程 , 编译器所进行的操作顺序是  : 

      ```
      1. 分配一块内存 M；
      2. 在内存 M 上初始化 Singleton 对象；
      3. 然后 M 的地址赋值给 instance 变量。
      ```

      实际上却是 : 

      ```
      1. 分配一块内存 M
      2. 然后 M 的地址赋值给 instance 变量
      3. 在内存 M 上初始化 Singleton 对象 
      ```

    

  - 被优化顺序后的整个执行顺序如下 : 

    ![双重检查创建单例的异常执行路径](http://assets.studymachine.cn/img/202111160001528.png)

    >  这样就会出现一个问题 , instance 被赋予一个未初始化实际对象的内存地址 ,  然后其他线程在判断 instance 是否为 null 时 , 就是判断通过  , 导致创建多一个对象 , 违背单例.





# 02 | Java内存模型：看Java如何解决可见性和有序性问题



## Java 内存模型的处理方法

- cpu 缓存 => 可见性问题
- 编译优化 => 有序性问题
- 最简单粗暴的解决办法 : 全盘**禁用cpu 缓存**  && **禁用编译优化** .  **(不可取 !! 会导致程序性能极低 )** 
- 合理的办法 :  **按需**进行上述禁用
- JVM 如何按需进行禁用缓存以及指令优化 ? 
  - **volatile**
  - **synchronized** 
  - **final** 
  - 六项 **Happens-Before 规则**



## volatile

- 作用 : 声明于变量 , 禁用CPU缓存. 读写均直接从内存中操作 . 

-  存在问题 : 

  ```java
  class VolatileExample {
    int x = 0;
      
    volatile boolean v = false;
      
    // 线程 A 执行 writer()
    public void writer() {
      x = 42;
      v = true;
    }
      
    // 线程 B 执行 reader()
    public void reader() {
      if (v == true) {
        // 这里 x 会是多少呢？
      }
    }
  }
  ```
  
  - Java 1.5 之前 ,  当执行到 `v == true` 时 ,   后续读取到 `x` 的值 , 可能还是 0  . 这是由于我们前面所说的过的CPU缓存导致的.   
  - 而 Java 1.5 以及之后的版本就不会出现这种情况了 , 读取到的必然是 前面赋值的 42 .  具体是原因就是 **Happens-Before 规则**



## Happens-Before 六大规则

- 简单描述 : 前面的操作结果对后续的操作结果是可见的.

  > 个人总结 :  就是 `volatile` 变量 的**前面的变量**改动的结果 , 对 `volatile` 变量是可见的. 

### 1. 顺序性规则

- **`volatile` 修饰的变量相关的代码** 的前面的代码 , 是不会被指令重排到 其之后的.



### 2. 变量规则

- 一个 `volatile ` 变量的写操作  , 对于后续的这个 `volatile` 变量的读操作是可见的 .  ( 也可以简单理解为禁用CPU缓存.)



### 3. 传递性

- 描述 : 如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。

  ![](http://assets.studymachine.cn/img/202111170026206.png)

-  简单描述 : 

  - 线程A  `x = 42`  在  happen before `写变量 v = true`  (规则1)
  - 线程A `写变量 v = true`  happen before `读变量 v = true ` (规则2) 
  -  所以 , 由于传递性 `线程A 中的 x = 42` , 对 `线程B中 读取到 v = true `时 , 是可见的 . 



### 4. 管程中锁的规则

- **描述** : 对一个锁的`解锁` **Happens-Before** 于后续对这个锁的`加锁`

- **什么是管程 ?** 

  - **管程**是一种通用的同步原语，在 Java 中指的就是 synchronized
  - synchronized 是 Java 里对管程的实现

- **个人理解** : 即加锁修改共享变量的操作 , 在解锁后 , 该修改被其他线程再次加锁时 , 是可见的 .  如下 : 

  ```java
  synchronized (this) { // 此处自动加锁
    // x 是共享变量, 初始值 =10
    if (this.x < 12) {
      this.x = 12; 
    }  
  } // 此处自动解锁
  ```

  线程A 加锁  设置 x = 12  , 然后解锁 .  线程B 再次加锁后进入同步代码块 , 是可以看到 x = 12的 . 





### 5. 线程start( ) 规则

- **描述** : 线程A中调用 线程B的  `start()` 方法 , 则 **线程A  happens-before 线程B**  方法 , 线程 A 中调用B的start() 方法之前的修改 , 对后续线程B 来说是可见的 . 

- 例如 : 在线程A 中运行如下代码 . 

  ```java
  Thread B = new Thread(()->{
    // 主线程调用 B.start() 之前
    // 所有对共享变量的修改，此处皆可见
    // 此例中，var==77
  });
  // 此处对共享变量 var 修改
  var = 77;
  // 主线程启动子线程
  B.start();
  ```

  B start() 后 , 在 B 中看到 var 的值应该是 77 . 







### 6. 线程 join ( ) 规则

- 描述 : 线程 A 中调用 B 的 `join()` 方法.  则说B 中任意操作 , 均 happens-before A的调用B 的 `join()` 的这个操作 .   

- 换句话说 : A中调用 B 的join , 则 B 中任何操作 , 对 A 中 join 之后来说 , 都是可见的.  如下代码所示 : 

  ```java
  Thread B = new Thread(()->{
    // 此处对共享变量 var 修改
    var = 66;
  });
  // 例如此处对共享变量修改，
  // 则这个修改结果对线程 B 可见
  // 主线程启动子线程
  B.start();
  B.join()
  // 子线程所有对共享变量的修改
  // 在主线程调用 B.join() 之后皆可见
  // 此例中，var==66
  ```

  



## final 关键字

- **作用 :** 被修饰的变量是不可变的 , 被修饰的类是不可被继承的. 

- jdk1.5 之前 , 被 `final` 修饰的变量 , 会由于编译器优化 , 构造函数指令重排的原因 , 导致可以看到被final 修饰的值是会变化的

- jdk 1.5 之后 , 只要不出现 **构造函数逸出** 的现象 , 被final 修饰的变量 , 是遵循其语义的 . 

- 什么是 **构造函数逸出** ?

  - 构造中 , 指定 `this` 赋值给全局变量 .  

  ```java
  // 以下代码来源于【参考 1】
  final int x;
  // 错误的构造函数
  public FinalFieldExample() { 
    x = 3;
    y = 4;
    // 此处就是讲 this 逸出，
    global.obj = this;
  }
  ```

  





# 03 | 互斥锁（上）：解决原子性问题



## 原子性问题如何解决?

- 原子性问题回顾 : 问题源头是**线程切换**
- 粗暴解决方案 : 禁用CPU 切换
  - 缺陷 : 不适用于多核CPU 
- 最佳实践思路 : **互斥** , 即同一时刻共享资源的操作是只能由一个线程执行 . 
  - 实现方式 : 加锁 .



## 简易锁模型

![](http://assets.studymachine.cn/img/202111230108418.png)



## Java 语言提供的锁技术 : synchronize

- Java 编译器会在 `synchronized `修饰的方法或代码块前后自动加上加锁 `lock()` 和解锁 `unlock()`

- `synchronized`修饰代码块 , 自行指定锁对象
- `synchronized`修饰对象方法  , 锁对象默认是`this` 
- `synchronized`修饰静态方法 , 锁对象是 `方法所在类.class` 对象



### 用 synchronized 解决 count+=1 问题

```java
class SafeCalc {
  long value = 0L;
  long get() {
    return value;
  }
  synchronized void addOne() {
    value += 1;
  }
}
```

- 上述代码可以保证 1000个线程同时调用 `addOne()`  , `value` 的最终结果一定是 1000 . 
- 但是在1000个线程同时调用过程中,  无法保证`get()` 方法 获取到的数据是实时数据  . 
  - 解决这个问题 , 只能要给 `get()` 方法也加锁  . 





## 锁与受保护资源的关系

- 被锁保护的资源可以是多个 ,   而要保证处理这些对象的操作是互斥的  , 则多个资源的锁只能是唯一一个 .  即**受保护资源和锁之间的关联关系是 N:1 的关系**。





# 04 | 互斥锁（下）：如何用一把锁保护多个资源？



## 保护没有关联关系的多个资源

- 保护**没有关系的多个资源 , 不需要共用一把锁** .  只需要各自使用各自的锁对象 , 保证各个对象的存取操作都是互斥的即可 .
- **延伸概念** : 锁的细粒度 . 锁覆盖的资源越少 , 粒度越细 , 性能越高. 
- **用不同的锁对受保护资源进行精细化管理，能够提升性能**。这种锁还有个名字，叫**细粒度锁**。



## 保护有关系的多个资源

- 示例 : 银行里的转账操作 : A 账户对 B 账户进行转账

  - Account 类 : 

    ```java
    class Account {
      // 账户余额 
      private int balance;
    
      // 转账
      synchronized void transfer(Account target, int amt){
        if (this.balance > amt) {
          this.balance -= amt;
          target.balance += amt;
        }
      } 
    }
    ```

  - **上述代码存在问题** : 如果是 Account  A 调用  `transfer()` ,  入参为 Account B , 此时转账方法中的 `synchronized` 默认所对象为`this `. 而两个 Account 对象分属不同对象 , 所以这里的加锁操作无法对两个 Account 对象 同时进行锁定 .  仅可锁定调用方的 Account 对象 , 也就是A . 

- 正确加锁思路 : 所有资源都应该使用同一个锁对象进行加锁 . 

- 正确加锁示例 : 使用`Account.class` 作为转账方法的锁对象 .   

  >  (ps. 该示例实践中不可行 , 性能过低 , 使得所有的转账操作均串行化 .)

  ```java
  class Account {
    private int balance;
    // 转账
    void transfer(Account target, int amt){
      synchronized(Account.class) {
        if (this.balance > amt) {
          this.balance -= amt;
          target.balance += amt;
        }
      }
    } 
  }
  ```





## 原子性的本质

- 多个高级语言操作看为一个不可分隔的过程 . 
- **操作的中间状态对外不可见**
- **解决原子性问题，是要保证中间状态对外不可见**。





# 05 | 一不小心就死锁了，怎么办？



## 什么是死锁

- 引入场景(转账) :  使用 `synchronize`  实现细粒度锁 .   `synchronize `分别锁转账操作双方的账户对象 .  

  ```java
  class Account {
    private int balance;
    // 转账
    void transfer(Account target, int amt){
      // 锁定转出账户
      synchronized(this){     ①
        // 锁定转入账户
        synchronized(target){ ②
          if (this.balance > amt) {
            this.balance -= amt;
            target.balance += amt;
          }
        }
      }
    } 
  }
  ```

  - 假设 A 转账 给 B  ,  A 成功申请自身锁对象 
  - 但是在获取B 锁对象时 . 由于B 也在进行对A 转账操作 , B也成功申请了自身 . 
  - 此时就会出现 A一直占有自己 , 等待 B  , B一直占有自己 , 等待A . 此时若双方都不释放自己手上申请到的资源 , 则进入无限等待状态 .  这种场景就叫做 **死锁** 

![](http://assets.studymachine.cn/img/202112012347729.png)





## 如何预防死锁

- 出现死锁一般没有很好的办法解决 ,  往往只能重启应用 . 
- 死锁只能避免 . 

### 死锁出现的条件

> 满足以下**所有条件**时 , 才会出现死锁 . 

- **互斥**  : 没啥好说的 , 没有互斥就没有锁这么一说了. 
- **占有且等待**  : 线程 T1 占有 A资源 , 在等待 B资源时 , 不释放A资源 . 
- **不可抢占** : 线程A不能强行抢占 线程B已经占有的资源 . 
- **循环**等待  :   这里注意循环二字 . 即A 线程占有 B 线程等待的资源 , B线程占有 A线程等待的资源 , 相互占有 , 相互等待 . 

> 所以 ,  加锁时 , 只要破坏上面其中一个条件 , 就不会出现死锁的现象 . 

