# 五、 一不小心就死锁了，怎么办？



## 1. 什么是死锁

- **细粒度锁**带来性能优化 , 同时也会导致出现死锁的问题 . 

- 引入场景(转账) :  使用 `synchronize`  实现细粒度锁 .   `synchronize `分别锁转账操作双方的账户对象 .  

  ```java
  class Account {
    private int balance;
    // 转账
    void transfer(Account target, int amt){
      // 锁定转出账户
      synchronized(this){     ①
        // 锁定转入账户
        synchronized(target){ ②
          if (this.balance > amt) {
            this.balance -= amt;
            target.balance += amt;
          }
        }
      }
    } 
  }
  ```

  - 假设 A 转账 给 B  ,  A 成功申请自身锁对象 
  - 但是在获取B 锁对象时 . 由于B 也在进行对A 转账操作 , B也成功申请了自身 . 
  - 此时就会出现 A一直占有自己 , 等待 B  , B一直占有自己 , 等待A . 此时若双方都不释放自己手上申请到的资源 , 则进入无限等待状态 .  这种场景就叫做 **死锁** 

![](http://assets.studymachine.cn/img/202112012347729.png)





## 2. 如何预防死锁

- 出现死锁一般没有很好的办法解决 ,  往往只能重启应用 . 
- 死锁只能避免 . 

### 2.1. 死锁出现的条件

> 满足以下**所有条件**时 , 才会出现死锁 . 

- **互斥**  : 没啥好说的 , 没有互斥就没有锁这么一说了. 
- **占有且等待**  : 线程 T1 占有 A资源 , 在等待 B资源时 , 不释放A资源 . 
- **不可抢占** : 线程A不能强行抢占 线程B已经占有的资源 . 
- **循环**等待  :   这里注意循环二字 . 即A 线程占有 B 线程等待的资源 , B线程占有 A线程等待的资源 , 相互占有 , 相互等待 . 



### 2.2. 如何避免出现死锁

> 上面提到 , 只有当4个条件同时满足时 , 才会出现死锁 . 
>
> 所以 ,  加锁时 , 只要破坏上面其中一个条件 , 就不会出现死锁的现象 . 



#### 2.2.1. 破坏占用且等待条件锁

// todo
